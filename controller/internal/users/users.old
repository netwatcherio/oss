package users

import (
	"errors"
	"fmt"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
	"time"
)

type User struct {
	ID          uint      `gorm:"primaryKey;autoIncrement" json:"id"`
	Email       string    `gorm:"column:email;uniqueIndex;not null" json:"email"` // email, will be used as username
	FirstName   string    `gorm:"column:first_name" json:"firstName"`
	LastName    string    `gorm:"column:last_name" json:"lastName"`
	Company     string    `gorm:"column:company" json:"company"`
	Admin       bool      `gorm:"column:admin;default:false" json:"admin"`
	Password    string    `gorm:"column:password" json:"password"`               // password in bcrypt
	Verified    bool      `gorm:"column:verified;default:false" json:"verified"` // verified, meaning email confirmation
	PhoneNumber string    `gorm:"column:phone_number" json:"phoneNumber"`
	Role        string    `gorm:"column:role" json:"role"`
	CreatedAt   time.Time `gorm:"column:created_at" json:"createdAt"`
	UpdatedAt   time.Time `gorm:"column:updated_at" json:"updatedAt"`
}

// TableName specifies the table name for GORM
func (User) TableName() string {
	return "users"
}

// Create returns error if unsuccessful, error will be nil if successful
func (u *User) Create(db *gorm.DB) error {
	// Check if user with email already exists
	existingUser := &User{Email: u.Email}
	_, err := existingUser.FromEmail(db)
	if err == nil {
		return fmt.Errorf("user exists")
	}

	// GORM automatically handles CreatedAt and UpdatedAt if you use the standard naming
	// But since we're using custom names, we'll set them manually
	u.CreatedAt = time.Now()
	u.UpdatedAt = time.Now()

	result := db.Create(u)
	if result.Error != nil {
		return fmt.Errorf("something went wrong creating user: %w", result.Error)
	}

	log.Infof("inserted user with the id %d", u.ID)
	return nil
}

// FromID returns a user if it finds a matching user with the provided ID
func (u *User) FromID(db *gorm.DB) (*User, error) {
	var user User
	result := db.Where("id = ?", u.ID).First(&user)

	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, errors.New("no user found")
		}
		return nil, fmt.Errorf("error finding user: %w", result.Error)
	}

	return &user, nil
}

// FromEmail returns a user if it was able to find someone that matches the email
func (u *User) FromEmail(db *gorm.DB) (*User, error) {
	var user User
	result := db.Where("email = ?", u.Email).First(&user)

	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, errors.New("no user found")
		}
		return nil, fmt.Errorf("error finding user: %w", result.Error)
	}

	return &user, nil
}

// BeforeCreate hook to ensure CreatedAt and UpdatedAt are set
func (u *User) BeforeCreate(tx *gorm.DB) error {
	if u.CreatedAt.IsZero() {
		u.CreatedAt = time.Now()
	}
	if u.UpdatedAt.IsZero() {
		u.UpdatedAt = time.Now()
	}
	return nil
}

// BeforeUpdate hook to ensure UpdatedAt is updated
func (u *User) BeforeUpdate(tx *gorm.DB) error {
	u.UpdatedAt = time.Now()
	return nil
}
