package auth

import (
	_ "context"
	"errors"
	"github.com/golang-jwt/jwt/v5"
	log "github.com/sirupsen/logrus"
	"gorm.io/gorm"
	"netwatcher-controller/internal"
	"netwatcher-controller/internal/agent"
	"netwatcher-controller/internal/users"
	"time"
)

type Session struct {
	ID        uint      `json:"item_id" gorm:"column:item_id"`
	IsAgent   bool      `json:"is_agent" gorm:"column:is_agent"`
	SessionID uint      `json:"session_id" gorm:"primaryKey;autoIncrement"`
	Expiry    time.Time `json:"expiry" gorm:"column:expiry"`
	Created   time.Time `json:"created" gorm:"column:created"`
	WSConn    string    `json:"ws_conn" gorm:"column:ws_conn"`
	IP        string    `json:"ip,omitempty" gorm:"column:ip"`
}

// TableName specifies the table name for GORM
func (Session) TableName() string {
	return "sessions"
}

// Create a session from user id, and include expiry, return error if fails
func (s *Session) Create(db *gorm.DB) error {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.Create"}

	s.Expiry = time.Now().Add(time.Hour * 24)
	s.Created = time.Now()

	if s.ID == 0 {
		ee.Message = "invalid id used to create session"
		return ee.ToError()
	}

	result := db.Create(s)
	if result.Error != nil {
		ee.Error = result.Error
		ee.Message = "unable to insert session into db"
		return ee.ToError()
	}

	return nil
}

// FromID returns a session if it finds a matching session with the provided ID
func (s *Session) FromID(db *gorm.DB) (*Session, error) {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.FromID"}

	var session Session
	result := db.Where("session_id = ?", s.SessionID).First(&session)

	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			ee.Message = "no sessions found"
			ee.Error = result.Error
			return nil, ee.ToError()
		}
		ee.Message = "unable to find sessions for id"
		ee.Error = result.Error
		return nil, ee.ToError()
	}

	return &session, nil
}

// GetAgent get the agent from the token, otherwise return error
func GetAgent(token *jwt.Token, db *gorm.DB) (*agent.Agent, error) {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.GetAgent"}

	claims := token.Claims.(jwt.MapClaims)
	itemId := claims["item_id"].(float64) // JWT numbers are float64
	sessionId := claims["session_id"].(float64)

	session := Session{SessionID: uint(sessionId)}
	s, err := session.FromID(db)
	if err != nil {
		return nil, err
	}

	if !s.IsAgent {
		ee.Message = "session is not an agent"
		return nil, ee.ToError()
	}

	if time.Now().After(s.Expiry) {
		ee.Error = errors.New("token expired")
		return nil, ee.ToError()
	}

	if uint(itemId) != s.ID {
		ee.Message = "id is invalid"
		return nil, ee.ToError()
	}

	a := &agent.Agent{ID: s.ID}
	err = a.Get(db)
	if err != nil {
		ee.Error = err
		return nil, ee.ToError()
	}

	return a, nil
}

func GetSessionID(token *jwt.Token) (uint, error) {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.GetSessionID"}

	claims := token.Claims.(jwt.MapClaims)
	sessionId, ok := claims["session_id"].(float64)
	if !ok {
		ee.Error = errors.New("invalid session_id in token")
		return 0, ee.ToError()
	}

	return uint(sessionId), nil
}

// GetUser get the user from the token, otherwise return error
func GetUser(token *jwt.Token, db *gorm.DB) (*users.User, error) {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.GetUser"}

	claims := token.Claims.(jwt.MapClaims)
	itemId := claims["item_id"].(float64)
	sessionId := claims["session_id"].(float64)

	session := Session{SessionID: uint(sessionId)}
	s, err := session.FromID(db)
	if err != nil {
		ee.Error = err
		return nil, ee.ToError()
	}

	if time.Now().After(s.Expiry) {
		ee.Error = errors.New("token expired")
		return nil, ee.ToError()
	}

	if uint(itemId) != s.ID {
		ee.Error = errors.New("id mismatch")
		return nil, ee.ToError()
	}

	user := users.User{ID: s.ID}
	fromID, err := user.FromID(db)
	if err != nil {
		ee.Message = "unable to find user"
		ee.Error = err
		return nil, ee.ToError()
	}

	return fromID, nil
}

func (s *Session) UpdateConnWS(db *gorm.DB) error {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.UpdateConnWS"}

	result := db.Model(&Session{}).Where("session_id = ?", s.SessionID).Update("ws_conn", s.WSConn)
	if result.Error != nil {
		ee.Message = "unable to update ws connection session"
		ee.Error = result.Error
		return ee.ToError()
	}

	log.Infof("Updated WSConn for Agent: %d WS: %d", s.ID, s.SessionID)

	return nil
}

func GetSessionFromWSConn(wsConn string, db *gorm.DB) (*Session, error) {
	ee := internal.ErrorFormat{Package: "internal.auth", Level: log.ErrorLevel, Function: "session.GetSessionFromWSConn"}

	var session Session
	result := db.Where("ws_conn = ?", wsConn).First(&session)

	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			ee.Error = errors.New("no session found")
			return nil, ee.ToError()
		}
		ee.Error = result.Error
		ee.Message = "error finding session"
		return nil, ee.ToError()
	}

	return &session, nil
}
